package db

import (
	"context"
	"database/sql"
	"fmt"
)

// For individual queries, we already have the Queries struct generated by sqlc
// However, each query only do 1 operation on 1 specific table.
// So Queries struct doesn’t support transaction.
// That’s why we have to extend its functionality by embedding it inside the Store struct like this

// we need the Store to have a sql.DB object because it is required to create a new db transaction.

type Store struct {
	*Queries
	db *sql.DB
}

// New() is created from sqlc, creates and returns a new Queries object
func newStore(db *sql.DB) *Store {
	return &Store{
		db:      db,
		Queries: New(db),
	}
}

func (store *Store) execTx(ctx context.Context, fn func(*Queries) error) error {
	// The BeginTx() function returns a transaction object or an error.
	// If error is not nil, we just return it immediately
	tx, err := store.db.BeginTx(ctx, &sql.TxOptions{})
	if err != nil {
		return err
	}

	// we have the queries that runs within transaction
	queries := New(tx)
	// we can call the input function with that queries, and get back an error
	err = fn(queries)
	if err != nil { // If the error is not nil
		// then we need to rollback the transaction by calling tx.Rollback()
		if rbErr := tx.Rollback(); rbErr != nil { // If the rollback error is also not nil
			// we have to report 2 errors.
			// So combine them into 1 single error using fmt.Errorf() before returning
			return fmt.Errorf("tx err: %v, rb err: %v", err, rbErr)
		}
		// In case the rollback is successful, we just return the original transaction error
		return err
	}

	// Finally, if all operations in the transaction are successful,
	// we simply commit the transaction with tx.Commit(), and return its error to the caller
	return tx.Commit()
}

// func (store *Store) TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error) {

// }
